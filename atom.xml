<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ontheway</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-09T08:41:15.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CarpeDiem</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java8新特性</title>
    <link href="http://yoursite.com/2020/10/15/Java8/"/>
    <id>http://yoursite.com/2020/10/15/Java8/</id>
    <published>2020-10-15T03:33:01.000Z</published>
    <updated>2020-10-09T08:41:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever </p></blockquote><h3 id="Java8-新特性"><a href="#Java8-新特性" class="headerlink" title="Java8    新特性"></a>Java8    新特性</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li><p>Lambda表达式</p><p>允许把函数作为一个方法的参数传递到方法中。</p></li><li><p>函数式接口</p><p>有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p></li><li><p>默认方法</p><p>接口可以有实现方法，而且不需要实现类去实现其方法</p></li><li><p>方法引用</p><p>可以直接引用已有的Java类或对象（实例）的方法或构造器</p></li><li><p>StreamAPI</p><p>对集合（Collection）对象功能的增强</p></li><li><p>Date Time API   </p><p>加强对日期与时间的处理</p></li><li><p>Optional类</p><p>解决空指针异常</p></li></ul><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>Lambda表达式，也可称为闭包。允许把函数作为方法的参数传递到方法中。lambda由逗号分隔的参数列表、-&gt;符号、函数体三部分组成。</p><p>语法：(parameters)-&gt;expression或(parameters)-&gt;{statements;}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonCallBack</span> </span>&#123;    <span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">()</span></span>;     &#125; <span class="comment">// 定义接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String name, PersonCallBack callBack)</span> </span>&#123;    </span><br><span class="line">    System.out.println(name);    </span><br><span class="line">    callBack.callback();   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">new</span> Person().test(<span class="string">"张三"</span>, () -&gt; &#123;        </span><br><span class="line">        System.out.println(<span class="string">"18"</span>);    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要声明PersonCallBack接口为<strong>函数式接口</strong>。即接口中有且仅有唯一的一个抽象方法。lambda表达式其实就实现接口并且实现了接口中的唯一的方法。</p><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li><li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号</li><li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，使用大括号需要指定表达式返回一个数值。</li></ul><p>注意：lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。</p><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以由多个非抽象方法的接口。@FunctionalInterface可以校验函数式接口。</p><p>在Java8中新增了很多函数式接口。在java.util.function包下。使我们使用lambda接口更加方便。下面列举常用接口。</p><table><thead><tr><th align="center">接口</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Supplier</td><td align="center">无参数，返回一个结果</td></tr><tr><td align="center">Function</td><td align="center">接受一个输入参数，返回一个结果</td></tr><tr><td align="center">Consumer</td><td align="center">接受一个输入参数，无返回结果</td></tr></tbody></table><h4 id="默认方法和静态方法"><a href="#默认方法和静态方法" class="headerlink" title="默认方法和静态方法"></a>默认方法和静态方法</h4><p>接口中使用default修饰的方法为默认方法。用static修饰的方法为静态方法。</p><p>默认方法和静态方法就是接口可以有实现方法，而且不需要实现类去实现其方法。实现类也可以实现方法进行重写。</p><p><strong>为什么要有这个特性？</strong></p><p>首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的 java 8 之前的集合框架没有 foreach 方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。</p><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用通过方法的名字来指向一个方法，方法引用使用一对冒号::。</p><p>方法的参数列表必须与函数式接口的抽象方法的参数列表保持一致，返回值不做要求。</p><table><thead><tr><th align="center">引用类型</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">引用静态方法</td><td align="center">String::valueOf</td></tr><tr><td align="center">引用某个对象的方法</td><td align="center">list::add</td></tr><tr><td align="center">引用某个类的方法</td><td align="center">String::length</td></tr><tr><td align="center">引用构造方法</td><td align="center">HashMap::new</td></tr><tr><td align="center">引用数组</td><td align="center">int[]::new</td></tr></tbody></table><h4 id="Optional非空判断"><a href="#Optional非空判断" class="headerlink" title="Optional非空判断"></a>Optional非空判断</h4><p>引入Optional避免NullPointerException和层层判空的操作，代码更简洁</p><p>创建Optional对象的几个方法：</p><ul><li>Optional.of(T value)，返回一个Optional对象，value不能为空，否则会空指针异常</li><li>Optional.ofNullable(T value)，返回一个Optional对象，value可以为空</li><li>Optional.empty()，代表空</li><li>isPresent() : 判断是否包含值</li><li>orElse(T t) :  如果调用对象包含值，返回该值，否则返回t</li><li>orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值</li><li>map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()</li><li>flatMap(Function mapper):与 map 类似，要求返回值必须是Optional</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以前为了避免NPE，需要层层判空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (user.getCar() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user.getCar().getColor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> user.getCar().getColor();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"red"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引入Optional后</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">(Optional&lt;User&gt; optUser)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> optUser.map(User::getCar)</span><br><span class="line">            .map(Car::getColor)</span><br><span class="line">            .orElse(<span class="string">"red"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h4><p>Stream是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作，或者大批量数据操作。Stream API可以借助于新出现的Lambda表达式，极大的提高编程效率和程序的可读性。</p><p><strong>stream构成</strong></p><p>获取一个数据源（source）-&gt;数据转换-&gt;执行操作获取想要的结果，每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换）。</p><p><strong>stream的操作类型</strong></p><ul><li><p>中间操作</p><p>一个流后面可以跟随0个或多个中间操作。其目的是打开流，做出某种程度的数据映射、过滤、然后返回一个新的流，交给下一个操作使用。这类操作都是懒惰的，仅仅调用到这类方法，并没有真正开始流的遍历。</p></li><li><p>终止操作</p><p>一个流只能有一个终止操作，当这个操作执行后，流就被使 用“光”了，无法再被操作。终止操作的执行，才会真正开始流的遍历，并且会生成一个结果。</p></li></ul><p><strong>stream的使用</strong></p><ul><li><p>获取stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Collection.stream(); </span><br><span class="line">Collection.parallelStream();</span><br><span class="line">Arrays.stream();</span><br><span class="line">stream.of(T t);</span><br><span class="line"></span><br><span class="line">List list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Stream stream = list.stream();</span><br><span class="line">Stream stream = list.parallelStream();</span><br><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Stream stream = Arrays.stream(nums);</span><br><span class="line">Stream stream = Stream.of(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于基本数值型，目前提供了三种对应的包装类型 Stream</span></span><br><span class="line">IntStream,LongStream,DoubleStream</span><br></pre></td></tr></table></figure></li></ul><p><strong>Map/flatMap(映射)</strong></p><p>  把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。map 生成的是个 1:1 映射。ﬂatMap是一对多映射关系的。  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Student&gt; students = Arrays.asList(        </span><br><span class="line">    <span class="keyword">new</span> Student(<span class="number">1</span>, Grade.FIRST, <span class="number">60</span>),        </span><br><span class="line">    <span class="keyword">new</span> Student(<span class="number">2</span>, Grade.SECOND, <span class="number">80</span>),        </span><br><span class="line">    <span class="keyword">new</span> Student(<span class="number">3</span>, Grade.FIRST, <span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  <strong>map</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">students.stream().map(Student::getScore).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>  可以获取到id数组 [60, 80, 100]</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">students.stream().map(item -&gt; item.getId() + <span class="string">" "</span> + item.getScore()).collect(Collectors.joining(<span class="string">","</span>));</span><br></pre></td></tr></table></figure><p>  返回值为1 60,2 80,3 100</p><p>  <strong>flatMap</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; flatMapStream = Stream.of(        </span><br><span class="line">      Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),        </span><br><span class="line">      Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),        </span><br><span class="line">      Arrays.asList(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>  先执行map，结果为3 3 4，为流内部list的长度</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatMapStream.map(List::size).forEach(item -&gt; System.out.print(item + <span class="string">" "</span>));</span><br></pre></td></tr></table></figure><p>  在执行floatMap,结果为1 2 3 4 5 6 7 8 9 10</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatMapStream.flatMap(Collection::stream).forEach(item -&gt; System.out.print(item + <span class="string">" "</span>));</span><br></pre></td></tr></table></figure><p>  <strong>Map是把Stream中的每个List当做管道中的元素。flatMap是把Stream中的每个List的子元素当做管道中的元素</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flatMapStream.map(List::size).forEach(item -&gt; System.out.print(item + <span class="string">" "</span>));</span><br><span class="line">  flatMapStream.flatMap(Collection::stream).forEach(item -&gt; System.out.print(item + <span class="string">" "</span>));</span><br></pre></td></tr></table></figure><p>  当代码中同时出现对一个流的操作时，会出现什么问题？<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed</span><br></pre></td></tr></table></figure><br>  <strong>每次创建的stream只能使用一次</strong>  </p><p>  <strong>Map、flatMap的区别</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span><br><span class="line">flatMap(Function&lt;? <span class="keyword">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper); </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;<span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;&#125;</span><br></pre></td></tr></table></figure><p>  第一个参数是一样的，但是第二个不一样，flatMap要求返回的是继承stream类型的类型。也就是说函数体只能返回一个stream类型的流。</p><p><strong>Reduce</strong></p><p>  把 Stream 元素组合起来。它提供一个起始值，然后依照运算规则和Stream的每一个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Integer sum = Stream.of(nums).reduce(<span class="number">0</span>, (n1, n2) -&gt; n1 + n2);</span><br></pre></td></tr></table></figure><p>  第一个为起始值，第二个为运算规则。没有起始值时返回的是Optional。需要get()获取。</p><p><strong>filter(过滤)</strong></p><p>  用于通过设置的条件过滤出元素。  </p><p>  传递的是interface Predicate，返回值为boolean test(T t)，是否满足</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Stream.of(nums).filter(item -&gt; item &gt; <span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>  返回值为[4, 5, 6]。</p><p><strong>forEach（循环）终止操作</strong></p><p>  迭代流中的每个数据。forEach是一个终止操作。无法对一个流进行两次终止操作  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums &#x3D; new Integer[]&#123;1,2,3,4,5,6&#125;;</span><br><span class="line">Stream.of(nums).filter(item -&gt; item &gt; 3).forEach(System.out::print);</span><br></pre></td></tr></table></figure><p>  返回值为456  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure><p>  返回值为void，不会返回流，终止操作</p><p><strong>peek（循环）中间操作</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Stream.of(nums).filter(item -&gt; item &gt; <span class="number">3</span>)        </span><br><span class="line">    .peek(item -&gt; System.out.print(item + <span class="number">1</span>))        </span><br><span class="line">    .peek(System.out::print)        </span><br><span class="line">    .reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure><p>  可以多次peek操作。注意：结果为546576。 这个结果不好解释，自己体会吧。</p><p>  第一次的peek操作修改数据不会对第二次的peek数据造成影响。因为peek传递的是Consumer类型的函数体，只能消费，不能返回</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">peek</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure><p>  会返回流</p><p><strong>Limit/skip</strong></p><p>  limit 返回 Stream 的前面 n 个元素；skip 则是跳过前 n 个元素  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Stream.of(nums).limit(<span class="number">4</span>).skip(<span class="number">2</span>).forEach(System.out::print);</span><br></pre></td></tr></table></figure><p>  去前四个元素并跳过前两个。返回值为34</p><p><strong>sorted（排序）</strong></p><p>  对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、ﬁlter、 limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间  </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Stream.of(nums).sorted((x, y)-&gt;x.compareTo(y)).forEach(System.out::print);</span><br></pre></td></tr></table></figure><p>  返回结果2234456</p><p><strong>distinct（去重）/min/max</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[]&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Stream.of(nums).distinct().forEach(System.out::print); <span class="comment">//42356</span></span><br><span class="line">System.out.println(Stream.of(nums).min(Comparator.naturalOrder()).get()); <span class="comment">// 2</span></span><br><span class="line">System.out.println(Stream.of(nums).max(Comparator.naturalOrder()).get()); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p><strong>Match(匹配)</strong></p><p>  Stream 有三个 match 方法，从语义上说：  </p><ul><li><p>allMatch：Stream 中全部元素符合传入的 predicate，返回 true  </p></li><li><p>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true  </p></li><li><p>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true  </p><p>Integer[] nums = new Integer[]{4,2,2,4,3,5,6}; System.out.println(Stream.of(nums).anyMatch(x -&gt; x&gt;5)); // true</p></li></ul><p><strong>groupingBy/partitioningBy（分组）</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Student&gt; students = Arrays.asList(        </span><br><span class="line">    <span class="keyword">new</span> Student(<span class="number">1</span>, Grade.FIRST, <span class="number">60</span>),        </span><br><span class="line">    <span class="keyword">new</span> Student(<span class="number">2</span>, Grade.SECOND, <span class="number">80</span>),        </span><br><span class="line">    <span class="keyword">new</span> Student(<span class="number">3</span>, Grade.FIRST, <span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>  <strong>groupingBy</strong></p><p>  对上面的Student进行按年级进行分组</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">students.stream().collect(Collectors.groupingBy(Student::getGrade))</span><br><span class="line">    .forEach((grade, list) -&gt;&#123;    </span><br><span class="line">        System.out.print(grade + <span class="string">" -&gt; "</span>);    </span><br><span class="line">        list.forEach(s-&gt; System.out.print(<span class="string">"&#123;"</span> + s.getId() + <span class="string">","</span> + s.getGrade() + <span class="string">","</span> + s.getScore() + <span class="string">"&#125;"</span>));    </span><br><span class="line">        System.out.println();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  返回值为 SECOND -&gt; {2,SECOND,80} FIRST -&gt; {1,FIRST,60}{3,FIRST,100}  </p><p>  <strong>partitioningBy</strong></p><p>  对上面的Student进行按成绩进行分组</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">students.stream().collect(Collectors.partitioningBy(student -&gt; student.getScore() &gt; <span class="number">60</span>))</span><br><span class="line">    .forEach((grade, list) -&gt;&#123;    </span><br><span class="line">        System.out.print(grade + <span class="string">" -&gt; "</span>);    </span><br><span class="line">        list.forEach(s-&gt; System.out.print(<span class="string">"&#123;"</span> + s.getId() + <span class="string">","</span> + s.getGrade() + <span class="string">","</span> + s.getScore() + <span class="string">"&#125;"</span>));    </span><br><span class="line">        System.out.println();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>  返回值为 false -&gt; {1,FIRST,60} true -&gt; {2,SECOND,80}{3,FIRST,100}</p><p><strong>parallelStream</strong></p><p>  parallelStream其实就是一个并行执行的流.其底层使用Fork/Join框架实现，可以提高你的多线程任务的速度。  </p><p>  可以通过parallel（）把stream转换为并行执行流。也可以通过parallelStream()获取。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Arrays.stream(nums).forEach(System.out::print); <span class="comment">// 126321425</span></span><br><span class="line">System.out.println();</span><br><span class="line">Arrays.stream(nums).parallel().forEach(System.out::print); <span class="comment">// 122546321</span></span><br></pre></td></tr></table></figure><p> 注意：</p><p> 使用并行执行流可以提高多线程任务速度，但是也会改变数组的遍历顺序（仅从上面例子上发现）。</p><p> parallelStream适合没有线程安全问题。</p><p>parallelStream底层是使用的ForkJoin。而ForkJoin里面的线程是通过ForkJoinPool来运行的，Java 8为 ForkJoinPool添加了一个通用线程池，这个线程池用来处理那些没有被显式提交到任何线程池的任务。它是 ForkJoinPool类型上的一个静态元素。它拥有的默认线程数量等于运行计算机上的处理器数量，所以这里就出现 了这个java进程里所有使用parallelStream的地方实际上是公用的同一个ForkJoinPool。parallelStream提供了更 简单的并发执行的实现，但并不意味着更高的性能，它是使用要根据具体的应用场景。如果cpu资源紧张 parallelStream不会带来性能提升；如果存在频繁的线程切换反而会降低性能。  </p><p><strong>Collect(流转换为其他数据结构)</strong></p><p>  转换为list</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; nums = Stream.of(<span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>&#125;);</span><br><span class="line">List&lt;String&gt; list = nums.collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>  也可以这样写</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = nums.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><p>  转换为字符串</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str =nums.collect(Collectors.joining());</span><br></pre></td></tr></table></figure><p> <strong>Stream API总结</strong></p><ul><li>stream不是数据结构，它没有内部存储，它只是用操作管道从source抓取数据 </li><li>Stream的操作会产生一个新Stream，而不是从source修改后得到</li><li>所有 Stream 的操作必须以 lambda 表达式为参数 </li><li>惰性化，很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始，中间操作永远是惰性化的。</li><li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li></ul><h4 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date Time API"></a>Date Time API</h4><p>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。</p><p><strong>java8之前</strong></p><ul><li><strong>非线程安全</strong> java.util.Date 是非线程安全的，所有的日期类都是可变的</li><li><strong>设计很差</strong> 日期/时间类的定义不一致，在java.util和java.sql的包中都有日期类。</li><li><strong>时区处理麻烦</strong> 日期类并不提供国际化，没有时区支持</li></ul><p>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。</p><p><strong>LocalDate类</strong></p><p>LocalDate只持有ISO-8601格式且无时区信息的日期部分  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate now = LocalDate.now(); <span class="comment">// 2020-10-08</span></span><br><span class="line">now = now.plusDays(<span class="number">2</span>);  <span class="comment">// 2020-10-10</span></span><br><span class="line">now = now.plusMonths(<span class="number">1</span>); <span class="comment">// 2020-11-10</span></span><br><span class="line">now = now.minusMonths(<span class="number">1</span>); <span class="comment">// 2020-10-10</span></span><br><span class="line">now = now.minusDays(<span class="number">2</span>); <span class="comment">// 2020-10-08</span></span><br><span class="line">LocalDate date3 = LocalDate.of(<span class="number">2020</span>, Month.DECEMBER, <span class="number">12</span>); <span class="comment">// 2020-12-12</span></span><br></pre></td></tr></table></figure><p>获取当前日期，对其进行修改</p><p><strong>LocalTime类</strong></p><p>LocalTime只持有ISO-8601格式且无时区信息的时间部分  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now = LocalTime.now(); <span class="comment">// 22:10:54.613</span></span><br><span class="line">now = now.plusMinutes(<span class="number">12</span>); <span class="comment">// 22:22:54.613</span></span><br><span class="line">now = now.minusHours(<span class="number">2</span>); <span class="comment">// 20:22:54.613</span></span><br><span class="line">System.out.println(now.format(DateTimeFormatter.ofPattern(<span class="string">"HH:mm:ss"</span>))); <span class="comment">// 20:22:54</span></span><br><span class="line">LocalTime date4 = LocalTime.of(<span class="number">22</span>, <span class="number">15</span>, <span class="number">30</span>); <span class="comment">// 20:15:30</span></span><br><span class="line">LocalTime date5 = LocalTime.parse(<span class="string">"20:15:30"</span>); <span class="comment">// 20:15:30</span></span><br></pre></td></tr></table></figure><p>获取当前时间，对其进行修改  </p><p><strong>LocalDateTime类</strong></p><p>LocaleDateTim把LocaleDat与LocalTime的功能合并起来  </p><p><strong>ZonedDateTime类</strong></p><p>从指定时区的系统时钟中获取当前日期时间。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime now = ZonedDateTime.now(ZoneId.of(<span class="string">"America/Los_Angeles"</span>));</span><br><span class="line">System.out.println(now); <span class="comment">// 2020-10-08T07:13:54.754-07:00[America/Los_Angeles]</span></span><br></pre></td></tr></table></figure><p>获取当前时区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZoneId currentZone = ZoneId.systemDefault();</span><br><span class="line">System.out.println(<span class="string">"当期时区: "</span> + currentZone); <span class="comment">// 当期时区: Asia/Shanghai</span></span><br></pre></td></tr></table></figure><p><strong>Clock类</strong></p><p>它通过指定一个时区，然后就可以获取到当前的时刻，日期与时间  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Clock shanghai = Clock.system(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line">System.out.println(LocalDateTime.now(shanghai)); <span class="comment">// 2020-10-08T22:15:39.999</span></span><br></pre></td></tr></table></figure><p><strong>Duration类</strong></p><p>Duration计算两个日期差  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime start = LocalDateTime.parse(<span class="string">"2020-01-01 22:10:10"</span>, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">LocalDateTime end = LocalDateTime.parse(<span class="string">"2020-02-01 22:15:10"</span>, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">Duration duration = Duration.between(start, end);</span><br><span class="line">System.out.println(duration.toDays()); <span class="comment">// 31</span></span><br><span class="line">System.out.println(duration.toHours()); <span class="comment">// 744</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Java8-新特性&quot;&gt;&lt;a href=&quot;#Java8-新特性&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="Java8" scheme="http://yoursite.com/categories/Java8/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HTTP2浅析</title>
    <link href="http://yoursite.com/2020/10/09/http2/"/>
    <id>http://yoursite.com/2020/10/09/http2/</id>
    <published>2020-10-09T08:41:15.000Z</published>
    <updated>2020-10-09T08:41:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever </p></blockquote><h4 id="一、HTTP-1-1存在的问题"><a href="#一、HTTP-1-1存在的问题" class="headerlink" title="一、HTTP/1.1存在的问题"></a>一、HTTP/1.1存在的问题</h4><p>1、TCP连接数限制</p><p>对于同一个域名，浏览器最多只能同时创建6-8个TCP连接。</p><p>2、线头阻塞（Head Of Line Blocking）问题</p><p>每个TCP连接同时只能处理一个请求—响应，浏览器按FIFO原则处理请求，如果上一个响应没返回，后续请求—响应都会受阻。为了解决此问题，出现了管线化—pipelining技术，但是管线化存在诸多问题，比如第一个响应慢还是会阻塞后续响应，服务器为了按序返回响应需要缓存多个响应占用更多资源，浏览器中途断连重试服务器可能得重新处理多个请求，还有必须客户端-代理-服务器都支持管线化。</p><p>3、Header内容多，而且每次请求Header不会变化太大，而且没有响应的压缩传输优化方案。</p><p>4、为了尽可能减少请求数，需要做合并文件、资源内联等优化方案，但是无疑造成了单个请求内容变大延迟变高问题，且内嵌的资源不能有效地使用缓存机制。</p><p>5、明文传输不安全</p><h4 id="二、HTTP2的优势"><a href="#二、HTTP2的优势" class="headerlink" title="二、HTTP2的优势"></a>二、HTTP2的优势</h4><p>1、二进制分帧层（Binary Framing Layer）</p><p>帧是数据传输的最小单位，以二进制传输代替原本的明文传输，原本的报文消息被划分为更小的数据帧：</p><p><img src="http2/http1.jpg" alt="http2"><span class="img-alt">http2</span></p><p>2、多路复用（MultiPlexing）</p><p>在一个TCP连接上，我们可以向对方不断发送帧，每帧的stream identifier的标明这一帧属于哪个流，然后在对方接收时，根据stream identifier拼接每个流的所有帧组成一整块数据。把HTTP/1.1每个请求都当成一个流，那么多个请求变成多个流，请求响应数据分成多个帧，不同流中的帧交错地发送给对方，这就是HTTP/2中地多路复用。</p><p>流的概念实现了单连接上多请求—相应并行，解决了线头阻塞的问题，减少了TCP连接数量和TCP连接慢启动造成的问题。</p><p>所以HTTP2对于同一域名只需创建一个连接，而不像HTTP/1.1那样创建6-8个连接。</p><p>3、服务端推送（Server Push）</p><p>浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。</p><p>Server-Push主要是针对资源内联做出的优化，相较于http/1.1资源内联的优势：</p><ul><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送来的资源</li><li>推送资源可以由不同页面共享</li></ul><p>4、Header压缩（HPACK）</p><p>我们知道，http请求和响应都是由【状态行、请求/响应头部、消息主题】三部分组成的。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件（如图片、音频等），但是状态行和头部多是没有经过任何压缩，而是直接以纯文本的方式进行传输的。</p><p>使用HPACK算法来压缩首部内容，这种算法通过服务端和客户端各自维护索引表来实现。索引表又分为静态表和动态表。</p><ul><li><p>伪头字段</p><p>Header传输以二进制帧的方式进行，为了与HTTP1中的Header区分，这些以冒号开头的字段被称为“伪头字段”</p><p><img src="http2/http2.jpg" alt="伪头字段"><span class="img-alt">伪头字段</span></p></li><li><p>静态表</p><p>静态表中定义了61个Header字段与Index，可以通过传输Index进而获取Header的字段与值，极大减少了报文大小。静态表中的字段和值固定，而且只是只读的。</p><p>静态表部分值</p><p><img src="http2/http3.jpg" alt="静态表"><span class="img-alt">静态表</span></p></li><li><p>动态表</p><p>动态表接在静态表之后，结构与静态表相同，可随时更新。下图中索引号62、63即为动态表字段。</p><p><img src="http2/http4.jpg" alt="动态表"><span class="img-alt">动态表</span></p></li></ul><p>客户端通过传输索引号，服务端根据索引号在动态表中获取Header的key与value。另外，索引表中不存在的使用huffman编码，再更新到动态表中</p><p>5、应用层的重置连接</p><p>对于HTTP/1来说，是通过设置tcp segment里的reset flag来通知对端关闭连接的。这种方式会直接断开连接，下次再发请求就必须重新建立连接。HTTP/2引入RST_STREAM类型的frame，可以在不断开连接的前提下取消某个request的stream，表现更好。</p><p>6、请求优先级设置</p><p>HTTP/2里的每个stream都可以设置依赖（Dependency）和权重，可以按依赖树分配优先级，解决了关键请求被阻塞的问题。</p><p>7、流量控制</p><p>每个http2流都拥有自己的公示的流量窗口，它可以限制另一端发送数据。对于每个流来说，两端都必须告诉对方自己还有足够的空间来处理新的数据，而在该窗口被扩大前，另一端只被允许发送这么多数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;一、HTTP-1-1存在的问题&quot;&gt;&lt;a href=&quot;#一、HTTP-1-1存在的问题&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="HTTP/2" scheme="http://yoursite.com/categories/HTTP-2/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="http://yoursite.com/2020/06/19/Index1/"/>
    <id>http://yoursite.com/2020/06/19/Index1/</id>
    <published>2020-06-19T01:58:21.000Z</published>
    <updated>2020-06-29T01:58:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever </p></blockquote><p>提到数据库索引，大家应该都不陌生，但它的底层原理是什么呢，在此将最近所学的记录一下~</p><h4 id="一、什么是索引，为什么建立索引"><a href="#一、什么是索引，为什么建立索引" class="headerlink" title="一、什么是索引，为什么建立索引"></a>一、什么是索引，为什么建立索引</h4><p>索引就是用于快速找出所需要的特定值(一般就是某一列的某一行的值)，如果不使用索引，MySQL必须从第一条数据开始查找到整个表，找出相关的行，表越大，查找数据所需的时间也就越多，这才实际生产环境下是不允许的。因此，如果待查询的列有相关的索引，MySQL便能够快速到达一个位置去搜索数据文件，而不必查找所有数据，节省不少时间，提高了效率。</p><h4 id="二、B-Tree-原理"><a href="#二、B-Tree-原理" class="headerlink" title="二、B+ Tree 原理"></a>二、B+ Tree 原理</h4><h5 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h5><p>B Tree指的是Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p><p>B+ Tree 是基于B Tree和叶子节点顺序访问指针进行实现，它具有B Tree的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在B+ Tree中，一个节点中的key从左到右非递减排列，如果某个指针的左右相邻key分别是keyi和keyi+1,且不为null,则该指针指向节点的所有key大于等于keyi且小于等于keyi+1。</p><h5 id="2、操作"><a href="#2、操作" class="headerlink" title="2、操作"></a>2、操作</h5><p>进行查找操作时，首先在根节点进行二分查找，找到一个key所在的指针，然后递归地在指针所指向地节点进行查找。直到查到叶子节点，然后在叶子节点上进行二分查找，找出key所对应的data。</p><p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p><h5 id="3、与红黑树比较"><a href="#3、与红黑树比较" class="headerlink" title="3、与红黑树比较"></a>3、与红黑树比较</h5><p>红黑树等平衡树也可以用来实现索引，但是文件系统以及数据库系统普遍采用B+ Tree作为索引结构，这是因为B+树访问磁盘数据有更高的性能。</p><h6 id="（1）B-Tree有更低的树高"><a href="#（1）B-Tree有更低的树高" class="headerlink" title="（1）B+ Tree有更低的树高"></a>（1）B+ Tree有更低的树高</h6><p>平衡树的树高O(h)=O(logdN)，其中d为每个节点的出度。红黑树的出度为2，而B+ Tree的出度一般非常大，所以红黑树的树高h很明显比B+ Tree大非常多。</p><h6 id="（2）磁盘访问原理"><a href="#（2）磁盘访问原理" class="headerlink" title="（2）磁盘访问原理"></a>（2）磁盘访问原理</h6><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块成为一页，内存与磁盘以页为单位交换数据，数据库系统将索引的一个节点的大小设置为页的大小，使得一次I/O就能完全载入一个节点。</p><p>如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ Tree相对于红黑树有更低的树高，进行寻道的次数和树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以B+ Tree更适合磁盘数据的读取。</p><h6 id="（3）磁盘预读特性"><a href="#（3）磁盘预读特性" class="headerlink" title="（3）磁盘预读特性"></a>（3）磁盘预读特性</h6><p>为了减少磁盘I/O操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快，并且可以利用预读特性，相邻的节点也能被预先载入。</p><h4 id="三、MySQL有哪些索引"><a href="#三、MySQL有哪些索引" class="headerlink" title="三、MySQL有哪些索引"></a>三、MySQL有哪些索引</h4><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现细节。</p><h5 id="1、B-Tree-索引"><a href="#1、B-Tree-索引" class="headerlink" title="1、B+ Tree 索引"></a>1、B+ Tree 索引</h5><p>是大多数MySQL存储引擎的默认索引类型。</p><p>建立索引后，不需要再进行全表扫描，只需要对树进行搜索即可，所以在查找效率上会高很多。</p><p>B+ Tree的有序性，不仅可以用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引，多个索引共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB的B+ Tree索引分为主索引和辅助索引。主索引的叶子节点data域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p>而辅助索引的叶子节点的data域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p><h5 id="2、哈希索引"><a href="#2、哈希索引" class="headerlink" title="2、哈希索引"></a>2、哈希索引</h5><p>哈希索引能以O(1)时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精准查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在B+ Tree索引之上再创建一个哈希索引，这样就让B+ Tree索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h5 id="3、全文索引"><a href="#3、全文索引" class="headerlink" title="3、全文索引"></a>3、全文索引</h5><p>MyISAM存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用MATCH AGAINST，而不是普通的WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB存储引擎在MySQL5.6.4版本中也开始支持全文索引。</p><h5 id="4、空间数据索引"><a href="#4、空间数据索引" class="headerlink" title="4、空间数据索引"></a>4、空间数据索引</h5><p>MyISAM存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><h4 id="四、索引的优化"><a href="#四、索引的优化" class="headerlink" title="四、索引的优化"></a>四、索引的优化</h4><h5 id="1、独立的列"><a href="#1、独立的列" class="headerlink" title="1、独立的列"></a>1、独立的列</h5><p>在进行查询时，索引列不能是表达式的一部分，也不能式函数的一部分，否则无法使用索引。例如以下查询不能使用actor_id列的索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 &#x3D; 5;</span><br></pre></td></tr></table></figure><h5 id="2、多列索引"><a href="#2、多列索引" class="headerlink" title="2、多列索引"></a>2、多列索引</h5><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用单列索引性能更好。例如以下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT file_id,actor_id FROM sakila.film_actor WHERE actor_id &#x3D; 1 AND film_id &#x3D; 1;</span><br></pre></td></tr></table></figure><h5 id="3、索引列的顺序"><a href="#3、索引列的顺序" class="headerlink" title="3、索引列的顺序"></a>3、索引列的顺序</h5><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也就越高。</p><p>例如下面语句显示的结果中customer_id的选择性比staff_id更高，因此最好把customer_id列挡在多列索引的前面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT staff_id)&#x2F;COUNT(*) AS staff_id_selectivity,</span><br><span class="line">COUNT(DISTINCT customer_id)&#x2F;COUNT(*) AS customer_id_selectivity,</span><br><span class="line">COUNT(*)</span><br><span class="line">FROM payment;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure><h5 id="4、前缀索引"><a href="#4、前缀索引" class="headerlink" title="4、前缀索引"></a>4、前缀索引</h5><p>对于BLOB、TEXT、和VARCHAR类型的列，必须使用前缀索引，只索引开始的部分字符。</p><ul><li>1、前缀长度的选取需要根据索引选择性来确定。例如以下语句（假设1000万条数据）：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM x_test WHERE x_name &#x3D; &#39;1892008.205824857823401.800099203178258.8904820949682635656.62526521254&#39;;</span><br></pre></td></tr></table></figure><p>查询时间:2.253s;</p><ul><li>2、添加前缀索引 ( 以第一位字符创建前缀索引 )</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table x_test add index(x_name(1))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM x_test WHERE x_name &#x3D; &#39;1892008.205824857823401.800099203178258.8904820949682635656.62526521254&#39;;</span><br></pre></td></tr></table></figure><p>查询时间:3.291s,当使用第一位字符创建前缀索引后 貌似查询的时间更长了，因为只第一位字符而言索引值的重读性太大了</p><ul><li>3、重新建立前缀索引 这次以前4位字符来创建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table x_test add index(x_name(4));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM x_test WHERE x_name &#x3D; &#39;1892008.205824857823401.800099203178258.8904820949682635656.62526521254&#39;;</span><br></pre></td></tr></table></figure><p>查询时间:0.703s，这次以前4位创建索引 大大减少了索引值的重复性 查询速度从3秒提升到0.7秒。</p><p>总之，前缀数要根据重复度视情况而定。</p><h5 id="5、覆盖索引"><a href="#5、覆盖索引" class="headerlink" title="5、覆盖索引"></a>5、覆盖索引</h5><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h4 id="五、索引的优点"><a href="#五、索引的优点" class="headerlink" title="五、索引的优点"></a>五、索引的优点</h4><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><h4 id="六、索引的使用条件"><a href="#六、索引的使用条件" class="headerlink" title="六、索引的使用条件"></a>六、索引的使用条件</h4><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul><h4 id="七、索引是否生效主要取决于字段类型"><a href="#七、索引是否生效主要取决于字段类型" class="headerlink" title="七、索引是否生效主要取决于字段类型"></a>七、索引是否生效主要取决于字段类型</h4><ul><li><p>如果字段类型为字符串，需要给in查询中的数值与字符串值都需要添加引号，索引才能起作用。</p></li><li><p>如果字段类型为int，则in查询中的值不需要添加引号，索引也会起叙用。</p><p>IN的字段，在联合索引中，按以上方法，也会起作用。</p></li><li><p>mysql查询优化器认为全表扫描时如果速度大于使用索引，就会不用索引，你可以使用FORCE INDEX强制mysql使用索引。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提到数据库索引，大家应该都不陌生，但它的底层原理是什么呢，在此将最近所学的记录一下~&lt;/p&gt;
&lt;h4 id=&quot;一、什么是索
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>fail-fast/safe迭代器区别</title>
    <link href="http://yoursite.com/2020/06/16/fail-fast-safe/"/>
    <id>http://yoursite.com/2020/06/16/fail-fast-safe/</id>
    <published>2020-06-16T08:09:09.000Z</published>
    <updated>2020-06-16T08:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever </p></blockquote><p>最近在看Java容器，在此记录下fail-fast和fail-safe两种迭代器的区别。</p><h4 id="1-fail-fast"><a href="#1-fail-fast" class="headerlink" title="1.fail-fast"></a>1.fail-fast</h4><p>fail-fast迭代器，如果直接在容器上进行遍历，在遍历过程中，一旦发现容器中的数据被修改了(比如增加、删除或者修改)，会立刻抛出ConcurrentModificationException异常导致遍历失败。</p><p>原因：在迭代的时候，先计算一个modCount变量，然后当执行hasNext()方法时，要判断modCount是否等于expectedModCount值，如果是，就返回遍历，否则就抛出异常，终止遍历。</p><p>注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p><p>场景：java.util包下的集合类(比如HashMap和ArrayList)都是fail-fast的，不能在多线程下发生并发修改。</p><h4 id="2-fail-safe"><a href="#2-fail-safe" class="headerlink" title="2.fail-safe"></a>2.fail-safe</h4><p>采用fail-safe迭代器机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有的集合内容，在拷贝的集合上进行遍历。</p><p>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会抛出异常。</p><p>缺点：基于对原集合的克隆虽避免了ConcurrentModificationException,但迭代器并不能访问到修改后的内容，所以不适用于实时性要求比较高的场景。</p><p>场景：java.util.concurrent包下的容器(比如ConcerrentHashMap和CopyOnWriteArrayList)都是fail-safe，可以在多线程下并发使用，并发修改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在看Java容器，在此记录下fail-fast和fail-safe两种迭代器的区别。&lt;/p&gt;
&lt;h4 id=&quot;1-fa
      
    
    </summary>
    
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java编程" scheme="http://yoursite.com/tags/Java%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Web页面的请求过程</title>
    <link href="http://yoursite.com/2020/05/20/web1/"/>
    <id>http://yoursite.com/2020/05/20/web1/</id>
    <published>2020-05-20T03:44:35.000Z</published>
    <updated>2020-05-20T03:44:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever</p></blockquote><p>当我们在浏览器查资料，输入所需要的网址时，按下回车，一个网页便会呈现在大家的眼前，就这几秒钟你知道浏览器到底发生了什么嘛？</p><p>本文就讲讲这个过程发生了什么吧？</p><pre class="mermaid">graph LR   输入URL --> DHCP配置主机信息   DHCP配置主机信息 --> ARP解析MAC地址   ARP解析MAC地址 --> DNS解析域名   DNS解析域名 --> HTTP请求页面</pre><ul><li><p><strong>1.URL</strong></p><p>输入所需网址</p></li><li><p><strong>2.DHCP配置主机信息</strong></p><ul><li>如果主机最开始没有IP地址以及其他信息，那么就需要先使用DHCP来获取</li><li>主机会生成一个DHCP请求报文，并将这个报文放入具有目的端口67和源端口68的UDP报文段中。</li><li>该报文段则被放入在一个具有广播IP目的地址(255.255.255.255)和源IP地址(0.0.0.0)的IP数据报中。</li><li>该数据报则被放置到MAC帧中，该帧具有目的地址FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备上。</li><li>连接在交换机的DHCP服务器收到广播帧之后，不断地向上分解得到IP数据报，UDP报文段，DHCP请求报文，之后生成DHCP ACK报文，该报文 包含以下信息：IP地址，DNS服务器地IP地址，默认网关路由器的IP地址和子网掩码。该报文被放入UDP报文段中，UDP报文段有被放入IP数据报中，最后放入MAC帧中。</li><li>该帧的目的地址是请求主机的MAC地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了MAC地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li><li>主机收到该帧后，不断分解得到DHCP报文。之后就配置它的IP地址，子网掩码和DNS服务器的IP地址，并在其IP转发表中安装默认网关。</li></ul></li><li><p><strong>3.ARP解析MAC地址</strong></p><ul><li>主机通过浏览器生成一个TCP套接字，套接字向HTTP服务器发送HTTP请求，为了生成该套接字，主机需要知道网站的域名对应的IP地址</li><li>主机生成一个DNS查询报文，该报文具有53号端口，因为DNS服务器的端口号是53。</li><li>该DNS查询报文被放入目的地址为DNS服务器IP地址的IP数据报中</li><li>该IP数据报被放入一个以太网帧中，该帧将发送到网关路由器</li><li>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</li><li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li><li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li></ul></li><li><p><strong>4.DNS解析域名</strong></p><ul><li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li><li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li><li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li><li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li><li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li></ul></li><li><p><strong>5.HTTP请求页面</strong></p><ul><li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li><li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li><li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li><li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li><li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li><li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我们在浏览器查资料，输入所需要的网址时，按下回车，一个网页便会呈现在大家的眼前，就这几秒钟你知道浏览器到底发生了什么嘛？&lt;
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Web页面的请求过程" scheme="http://yoursite.com/tags/Web%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>TCP之3次握手和4次挥手</title>
    <link href="http://yoursite.com/2020/05/20/TCP1/"/>
    <id>http://yoursite.com/2020/05/20/TCP1/</id>
    <published>2020-05-20T03:22:15.000Z</published>
    <updated>2020-05-20T03:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever</p></blockquote><h4 id="三次握手-three-way-handshake"><a href="#三次握手-three-way-handshake" class="headerlink" title="三次握手(three-way handshake)"></a>三次握手(three-way handshake)</h4><p><strong>意义</strong></p><p>TCP位于传输层，作用就是提供可靠安全的字节流服务，为了准确无误地将数据传送到客户或服务器，TCP协议则采纳了三次握手策略。</p><p><strong>过程</strong></p><p><img src="/2020/05/20/TCP1/tcp3.png" alt="TCP三次握手"><span class="img-alt">TCP三次握手</span></p><p>假设A为客户端，B为服务器端。</p><ul><li>首先B处于LISTEN(监听)状态，等待客户的连接请求。</li><li>A向B发送连接请求报文，SYN(同步)=1,ACK(确认)=0,选择一个初始地序号x。</li><li>B收到连接请求报文，如果同意建立连接，则向A发送连接确认报文，SYN=1，ACK=1，确认号为x+1，同时也选择一个初始的序号y。</li><li>A收到B的连接确认报文后，还要向B发出确认，确认号为y+1,序号为x+1。</li><li>B收到A的确认后，连接建立。</li></ul><p>形象化说法就是：</p><ul><li>Client:嗨，A，是我，听到没？</li><li>Server:我听到了，你能听到我没？</li><li>Client:好的，我们都能互相听到了，可以建立连接，通信了。</li></ul><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送地连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回地连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留地连接请求最后还是会达到服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有三次握手，客户端就会忽略服务器之后发送地对滞留连接请求地连接确认，不进行第三次握手，因此就不会在此打开连接。</p><h4 id="四次挥手-four-way-wavehand"><a href="#四次挥手-four-way-wavehand" class="headerlink" title="四次挥手(four-way wavehand)"></a>四次挥手(four-way wavehand)</h4><p><strong>意义</strong></p><p>客户端发送了FIN连接释放报文之后，服务器收到了这个报文，就进入了CLOSE-WAIT状态，这个状态是为了让服务器端发送还未还未传送完毕的数据，传送完毕后，服务器就会发送FIN连接释放报文。</p><p><strong>过程</strong></p><p><img src="/2020/05/20/TCP1/tcp4.png" alt="TCP四次挥手"><span class="img-alt">TCP四次挥手</span></p><ul><li>A发送连接释放报文，FIN=1.</li><li>B收到之后发出确认，此时TCP属于半关闭状态，B能向A发送数据但是A不能向B发送数据。</li><li>当B不再需要连接时，发送连接释放报文，FIN=1。</li><li>A收到后发出确认，进入TIME_WAIT状态，等待2MSL(最大报文存活时间)后释放连接。</li><li>B收到A的确认后释放连接</li></ul><p>形象化说法就是：</p><ul><li>Client:我所有数据都传完了</li><li>Server:我已经全部接收到了，但是等等我，我还没传完</li><li>Server:好了，我也已经传完了</li><li>Client:好的，那我们释放连接，通信结束。</li></ul><p><strong>TIME_WAIT</strong></p><p>在客户端接收到服务端的FIN报文后进入此状态，此时并不是直接进入CLOSED状态，还需要等待一个时间计时器设置的时间2MSL(超过此时间则结束TCP连接)，这么做的理由为：</p><ul><li>确保最后一个确认报文能够到达。如果B没收到A发送的确认报文，那么就会重新发送连接释放请求报文，A等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p><strong>常见问题</strong></p><ul><li><p>为什么连接的时候是三次握手，关闭的时候却是四次挥手？</p><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来确认的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步挥手。</p></li><li><p>如果已经建立了连接，但是客户端突然出现故障了怎么办？</p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;三次握手-three-way-handshake&quot;&gt;&lt;a href=&quot;#三次握手-three-way-handsh
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP之3次握手和4次挥手" scheme="http://yoursite.com/tags/TCP%E4%B9%8B3%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C4%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="http://yoursite.com/2020/05/18/HTTPStatusCode/"/>
    <id>http://yoursite.com/2020/05/18/HTTPStatusCode/</id>
    <published>2020-05-18T03:40:36.000Z</published>
    <updated>2020-05-18T03:40:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever</p></blockquote><p>最近又重温了一遍计算机网络，发现还是有好多知识点没掌握(又找借口，就是没学好🤣)。</p><p>作为一个Web端程序猿，怎么能不知道HTTP状态码呢！今天就来讲讲~</p><p>服务器返回的响应报文中第一行会有个状态行，它包含了状态码以及原因短语，用来告诉客户端请求的结果。</p><table><thead><tr><th align="center">状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td align="center">1XX</td><td>Informational(信息性状态码)</td><td>接收的请求正在处理</td></tr><tr><td align="center">2XX</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td align="center">3XX</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作以完成请求</td></tr><tr><td align="center">4XX</td><td>Client Error(客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td align="center">5XX</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><p><strong>1XX 信息</strong></p><ul><li><strong>100 Continue:</strong> 表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><p><strong>2XX 成功</strong></p><ul><li><strong>200 OK</strong></li><li><strong>204 No Content:</strong>请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送消息，而不需要返回数据时使用。</li><li><strong>206 Partial Content:</strong>表示客户端进行了范围请求，响应报文包含由Content-Range指定范围的实体内容。</li></ul><p><strong>3XX 重定向</strong></p><ul><li><strong>301 Moved Permanently:</strong>永久性重定向</li><li><strong>302 Found:</strong>临时性重定向</li><li><strong>303 See Other:</strong>和302有着相同的功能，但是303明确要求客户端应该采用GET方法获取资源</li><li><strong>304 Not Modified:</strong>如果请求报文首部包含一些条件，例如：If-Match,If-Modified-Since,If-None-Match,If-Range,If-Unmodified-Since,如果不满足条件，则服务器会返回304状态</li><li><strong>307 Temporary Redirect:</strong>临时重定向，与302的含义类似，但是307要求浏览器不会把重定向请求的POST方法改为GET方法。</li></ul><p><strong>4XX 客户端错误</strong></p><ul><li><strong>400 Bad Request:</strong>请求报文中存在语法错误</li><li><strong>401 Unauthorized:</strong>该状态码表示发送的请求需要有认证信息(BASIC认证，DIGEST认证)。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden:</strong>请求被拒绝</li><li><strong>404 Not Found</strong></li></ul><p><strong>5XX 服务器错误</strong></p><ul><li><strong>500 Internal Server Error:</strong>服务器正在执行请求时发生错误</li><li><strong>503 Service Unavailable:</strong>服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近又重温了一遍计算机网络，发现还是有好多知识点没掌握(又找借口，就是没学好🤣)。&lt;/p&gt;
&lt;p&gt;作为一个Web端程序猿，
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP状态码" scheme="http://yoursite.com/tags/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>递归与迭代的区别</title>
    <link href="http://yoursite.com/2020/05/03/fornote1/"/>
    <id>http://yoursite.com/2020/05/03/fornote1/</id>
    <published>2020-05-03T12:05:58.000Z</published>
    <updated>2020-05-03T12:05:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever</p></blockquote><p>递归与迭代还是会经常遇到的，不少小伙伴会经常理不清这两者的区别(包括我在内😏)，在此整理一下，希望对小伙伴们有帮助😎</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归到底是啥呢？</p><p><strong>递归</strong>(recursion):指的是在函数运行中调用函数自身的方法(A调用A)，但是递归不能一直让其递归下去(那不死循环啦😅)，所以构造递归方法必须满足两个条件：</p><ul><li><p>其一，子方法与原来的方法必须是处理的同一个问题</p></li><li><p>其二，不能无限制调用自身，必须有个终止条件，得到所需结果</p></li></ul><p>说了这么多，不够形象，说一些例子吧！</p><ul><li><p>斐波那契数列—指的是这样一个数列：1、1、2、3、5、8、13、21、……<br>这个数列从第三项开始，每一项都等于前两项之和，如何递归实现呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> n; <span class="comment">// n = 0, 1时给出recursion终止条件  </span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>阶乘 n! = n * (n-1) * (n-2) * …* 1(n&gt;0)，递归实现？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n*factorial(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了这两个例子，大家应该都理解了吧😊</p></li></ul><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>那迭代是啥呢？</p><p><strong>迭代</strong>(iteration):是利用已知的变量值，根据递推公式不断演进得到变量新值。简单地说，迭代是函数内某段代码实现循环。</p><p>都是循环，那迭代的循环和咱常见的普通循环有啥区别呢？</p><p>迭代与普通循环的<strong>区别</strong>：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</p><p>举几个栗子吧！</p><ul><li><p>斐波那契数列(不错，又是我)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用2个指针one、two分别指向前面2个数，然后相加移动</span></span><br><span class="line">    <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> two = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//最终结果</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        res = one + two;</span><br><span class="line">        one = two;</span><br><span class="line">        two = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>阶乘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过上面几个例子，大家需要注意下呀，通常情况下，<strong>在循环的次数较大时，迭代的效率明显高于递归，即迭代的时间复杂度低于递归的时间复杂度</strong>。</p><p><strong>end~&lt;(￣︶￣)↗[GO!]</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;递归与迭代还是会经常遇到的，不少小伙伴会经常理不清这两者的区别(包括我在内😏)，在此整理一下，希望对小伙伴们有帮助😎&lt;/
      
    
    </summary>
    
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>nginx初体验</title>
    <link href="http://yoursite.com/2020/05/03/nginxNote1/"/>
    <id>http://yoursite.com/2020/05/03/nginxNote1/</id>
    <published>2020-05-02T16:12:52.000Z</published>
    <updated>2020-05-05T16:12:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever</p></blockquote><h4 id="1、什么是nginx"><a href="#1、什么是nginx" class="headerlink" title="1、什么是nginx?"></a>1、什么是nginx?</h4><p>众所周知，nginx是一个高性能的HTTP和反向代理服务器，它占有内存少，并发能力强，实现上注重效率，能够接收高负载的考验，受到很多用户的青睐。</p><h4 id="2、什么是正向代理"><a href="#2、什么是正向代理" class="headerlink" title="2、什么是正向代理?"></a>2、什么是正向代理?</h4><p>说到反向代理，必须提一下正向代理。所谓正向代理，如果把本地网络外的网络(简称外网)想象成一个你要去的地方，假设本地网络中客户端要去外网，则需要通过代理服务器，这种代理服务就称为正向代理。</p><p>这也就需要在客户端(比如:浏览器)，配置代理服务器，通过代理服务器进行网络访问(注意:正向代理代理的是客户端)。</p><p>举个栗子:在现实网络中，我们是无法访问谷歌的，要想能够访问到，就需要某个东西代理访问(比如通过xxx.com网站)，但用户操作时是输入的<a href="http://www.google.com。" target="_blank" rel="noopener">www.google.com。</a></p><pre class="mermaid">graph LR   客户端. --> www.xxx.com   www.xxx.com --> www.google.com   客户端 --> www.google.com</pre><h4 id="3、什么是反向代理？"><a href="#3、什么是反向代理？" class="headerlink" title="3、什么是反向代理？"></a>3、什么是反向代理？</h4><p>说回反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需将请求发送给反向代理服务器(比如此处的nginx)，再由反向代理服务器去选择最终服务器，请求到数据后，再返回给客户端。而此时的反向代理服务器和目标服务器对外就是一个服务器，能够看到的是代理服务器地址，隐藏了真实服务器IP地址(反向代理代理的为服务器)</p><pre class="mermaid">graph LR   客户端 --> 80反向代理服务器   80反向代理服务器 --> 8090目标服务器比如tomcat服务器   80反向代理服务器 --> 8091目标服务器比如tomcat服务器   80反向代理服务器 --> ...</pre><h4 id="4、什么是负载均衡？"><a href="#4、什么是负载均衡？" class="headerlink" title="4、什么是负载均衡？"></a>4、什么是负载均衡？</h4><p>说nginx，必须要提<strong>负载均衡</strong>。</p><p>客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。这种处理逻辑没有任何问题，当并发请求较少时比较合适，节省资源。</p><pre class="mermaid">graph LR   客户端 --> 服务端   服务端 --> 数据库   数据库 --> 服务端   服务端 --> 客户端</pre><p>但这种请求会造成服务器响应客户端的请求日益缓慢，并发量大时，还容易造成服务器的崩溃，性能大打折扣。</p><p>因此，单个服务器解决不了，我们就增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的<strong>负载均衡</strong>，如图所示：</p><pre class="mermaid">graph LR   客户端 --> 80反向代理服务器   80反向代理服务器 --> 8090目标服务器比如tomcat服务器   80反向代理服务器 --> 8091目标服务器比如tomcat服务器   80反向代理服务器 --> ...</pre><h4 id="5、什么是动静分离？"><a href="#5、什么是动静分离？" class="headerlink" title="5、什么是动静分离？"></a>5、什么是动静分离？</h4><p>传统的部署都是将静态文件和动态资源部署到服务器，如图所示：</p><pre class="mermaid">graph LR   客户端-浏览器 --> 反向代理服务器   反向代理服务器 --> 服务器-将css.js等静态文件和servlet等动态资源部署到服务器</pre><p>而现在在前后端分离的趋势下，动静分离显得格外重要，而且更加方便，哈哈哈，话不多说，上图：</p><pre class="mermaid">graph LR   客户端-浏览器 --> 反向代理服务器   反向代理服务器 --> 服务器-将servlet等动态资源部署到服务器   反向代理服务器 --> 静态资源</pre><h4 id="6、配置文件"><a href="#6、配置文件" class="headerlink" title="6、配置文件"></a>6、配置文件</h4><p>说了这么多，看看如何配置nginx吧！我们需要配置<em>nginx.conf</em>文件。</p><p><strong>组成</strong></p><p><em>nginx.conf</em>文件由三部分组成</p><ul><li><p>第一部分 全局块</p><p>这部分主要设置一些影响nginx服务器整体运行的配置指令，主要包括配置运行Nginx服务器的用户(组)、允许生成的worker、<br>process数，进程PID存放路径、日志存放路径和类似以及配置文件的引入等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">#这是nginx服务器并发处理服务的关键配置，work_processes值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。</span><br><span class="line">worker_processes  1;</span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br></pre></td></tr></table></figure></li><li><p>第二部分 events块</p><p>events块涉及的指令主要影响Nginx服务器与用户的网络连接，常用的设置，包括是否开启对多work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个work process可以同时支持的最大连接数等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#此默认示例表示每个work process支持的最大连接数为1024</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第三部分 http块</p><p>Nginx服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块配置都在这里，http全局块配置的指令包括文件引入、MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上限等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">include       mime.types;</span><br><span class="line">default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">#log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">#&#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">#&#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">#access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">sendfile        on;</span><br><span class="line">#tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">#keepalive_timeout  0;</span><br><span class="line">keepalive_timeout  65;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全不一样的，该技术的产生是为了节省互联网服务器硬件成本。每个http块可以包括多个server块，而每个server块就相当于一个虚拟主机。而每个server块也分为全局server块，以及可以同时包含多个location块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#全局server块</span><br><span class="line">server &#123;</span><br><span class="line">  listen       80; #默认监听端口</span><br><span class="line">  server_name  localhost;</span><br><span class="line">#charset koi8-r;</span><br><span class="line"></span><br><span class="line">#access_log  logs&#x2F;host.access.log  main;</span><br><span class="line">#location块</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">   root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>动静分离配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 上游服务器</span><br><span class="line">upstream group&#123;</span><br><span class="line">#weight即权重，数值越大，优先级越高</span><br><span class="line">server 127.0.0.1:8090 weight&#x3D;2;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"># 配置服务器</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;group&#x2F;;</span><br><span class="line">tcp_nodelay     on;</span><br><span class="line">proxy_set_header Host            $host;</span><br><span class="line">        proxy_set_header X-Real-IP       $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br><span class="line"># 配置静态资源</span><br><span class="line">    location ~ .*\.(js|css|ico|png|jpg|eot|svg|ttf|woff|html|txt|pdf|gltf|) &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">expires 30d; #缓存30天</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>通过location指定不同的后缀名实现不同的请求转发。通过<strong>expires</strong>参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体Expires定义: 是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常<strong>适合不经常变动的资源</strong>。(如果经常更新的文件，不建议使用Expires来缓存)，如果设置30d, 表示在这30天之内访问这个URL, 发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304,如果有修改，则直接从服务器重新下载，返回状态码200。</p><p><strong>配置负载均衡</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#上游服务器</span><br><span class="line">upstream group&#123;</span><br><span class="line">#weight即权重，数值越大，优先级越高</span><br><span class="line">    server 192.168.0.12:80 weight&#x3D;1;</span><br><span class="line">    server 192.168.0.11:80 weight&#x3D;2;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    default_type  text&#x2F;html;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        echo &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;a&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;group&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>负载分配策略</strong></p><ul><li><p>1、轮询(默认)</p><p>每个请求按时间顺序逐一分配到不 同的后端服务器，如果后端服务器down掉，能自动剔除</p></li><li><p>2、weight<br>weight代表权重默认为1,权重越高被分配的客户端越多。<br>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。例如: 。</p></li><li><p>3、ip hash</p><p>每个请求按访问ip的hash结果分配, 这样每个访客固定访问一个后端服务器,可以解诀session的问题。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream server pool&#123;</span><br><span class="line">  ip_ hash</span><br><span class="line">  server 192.168.0.12:80</span><br><span class="line">  server 192.168.0.11:80</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>4、fair (第三方)<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream server_pool </span><br><span class="line">server 192.168.0.12:80;</span><br><span class="line">server 192.168.0.11:80;</span><br><span class="line">fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7、Nginx原理浅谈"><a href="#7、Nginx原理浅谈" class="headerlink" title="7、Nginx原理浅谈"></a>7、Nginx原理浅谈</h4><p><strong>①master和worker</strong></p><pre class="mermaid">graph TB   管理员--信号--> master进程   master进程--信号--> worker1进程   master进程 --信号--> worker2进程   master进程 --信号--> worker3进程   worker1进程 --连接--- Client1   worker1进程 --连接--- Client2   worker2进程 --连接--- Client3   worker2进程 --连接--- Client4   worker3进程 --连接--- Client5   worker3进程 --连接--- Client6</pre><p><strong>②worker如何进行工作的</strong></p><pre class="mermaid">graph LRclient --> MasterMaster--管理-监控---worker1Master--管理-监控---worker2Master--管理-监控---worker3Master--管理-监控---worker4worker1--争抢-->clientworker2--争抢-->clientworker3--争抢-->clientworker4--争抢-->clientworker1--争抢到-获取-->Tomcat1</pre><p>Master负责管理，监控并告知worker是否可以连接client，并请求连接服务器端。</p><p><strong>③一个master和多个worker的好处</strong></p><p>首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次,采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。当然，worker进程的异常退出，肯定是程序有bug了，异常退出，会导致当前worker.上的所有请求失败，不过不会影响到所有请求，所以降低了风险。</p><p><strong>④设置多少个worker合适</strong></p><p>Nginx同redis类似都采用了io多路复用机制，每个worker都是一个独立的进程， 但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求，即使是 千上万个请求也不在话下。每个worker的线程可以把一个cpu的性能发挥到极致。所以worker数和服务器的cpu数相等是最为适宜的。设少了会浪费cpu,设多了会造成cpu频繁切换上下文带来的损耗。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 设置worker数量</span><br><span class="line">worker.processes 4 </span><br><span class="line"></span><br><span class="line"># work绑定cpu(4work绑定4cpu)</span><br><span class="line">worker_cpu_affinity 0001 0010 0100 1000</span><br><span class="line"></span><br><span class="line"># work绑定cpu (4work绑定8cpu中的4个)</span><br><span class="line">worker_cpu_affinity 0000001 00000010 00000100 00001000</span><br></pre></td></tr></table></figure><p><strong>⑤连接数worker_ connection</strong></p><p>这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx 能建立的最大连接数，应该是worker.connections * worker processes。当然，这里说的是最大连接数，对于HTTP 请求本地资源来说，能够支持的最大并发数量是worker.connections * worker processes；如果是支持http1.1的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是: worker.connections * worker.processes / 2,；而如果是HTTP作为反向代理来说，最大并发数量应该是worker.connections * worker_proceses/4.。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。</p><p><strong>举例</strong></p><p>第一个: 发送请求，占用了woker的几个连接数?<br>答案: 2或者4个。</p><p>第二个: nginx有一个master,有四个woker,每个woker支持最大的连接数1024,支持的最大并发数是多少?<br>答案：普通的静态访问最大并发数是: worker connections * worker processes /2，<br>而如果是HTTP作为反向代理来说，最大并发数量应该是worker connections * worker processes/4</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1、什么是nginx&quot;&gt;&lt;a href=&quot;#1、什么是nginx&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://yoursite.com/2020/05/01/aboutme/"/>
    <id>http://yoursite.com/2020/05/01/aboutme/</id>
    <published>2020-05-01T15:11:44.000Z</published>
    <updated>2020-05-02T12:02:23.207Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever</p></blockquote><p>记得几年前就曾做了一个属于自己的博客，无奈当时没有坚持维护，如今正好有些时间，做了这个，将自己的读书，学习，生活记录于此。</p><p>希望这次我能长期维护这个博客，加油💪</p><p>要是偶然你们能够看到，希望所记录的东西能与你们分享，要是对你们有帮助那就更好了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记得几年前就曾做了一个属于自己的博客，无奈当时没有坚持维护，如今正好有些时间，做了这个，将自己的读书，学习，生活记录于此。&lt;
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="关于我" scheme="http://yoursite.com/tags/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
    
  </entry>
  
</feed>
