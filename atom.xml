<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ontheway</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-19T01:58:21.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CarpeDiem</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL索引</title>
    <link href="http://yoursite.com/2020/06/19/Index1/"/>
    <id>http://yoursite.com/2020/06/19/Index1/</id>
    <published>2020-06-19T01:58:21.000Z</published>
    <updated>2020-06-19T01:58:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever </p></blockquote><p>提到数据库索引，大家应该都不陌生，但它的底层原理是什么呢，在此将最近所学的记录一下~</p><h4 id="一、什么是索引，为什么建立索引"><a href="#一、什么是索引，为什么建立索引" class="headerlink" title="一、什么是索引，为什么建立索引"></a>一、什么是索引，为什么建立索引</h4><p>索引就是用于快速找出所需要的特定值(一般就是某一列的某一行的值)，如果不使用索引，MySQL必须从第一条数据开始查找到整个表，找出相关的行，表越大，查找数据所需的时间也就越多，这才实际生产环境下是不允许的。因此，如果待查询的列有相关的索引，MySQL便能够快速到达一个位置去搜索数据文件，而不必查找所有数据，节省不少时间，提高了效率。</p><h4 id="二、B-Tree-原理"><a href="#二、B-Tree-原理" class="headerlink" title="二、B+ Tree 原理"></a>二、B+ Tree 原理</h4><h5 id="1、数据结构"><a href="#1、数据结构" class="headerlink" title="1、数据结构"></a>1、数据结构</h5><p>B Tree指的是Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p><p>B+ Tree 是基于B Tree和叶子节点顺序访问指针进行实现，它具有B Tree的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在B+ Tree中，一个节点中的key从左到右非递减排列，如果某个指针的左右相邻key分别是keyi和keyi+1,且不为null,则该指针指向节点的所有key大于等于keyi且小于等于keyi+1。</p><h5 id="2、操作"><a href="#2、操作" class="headerlink" title="2、操作"></a>2、操作</h5><p>进行查找操作时，首先在根节点进行二分查找，找到一个key所在的指针，然后递归地在指针所指向地节点进行查找。直到查到叶子节点，然后在叶子节点上进行二分查找，找出key所对应的data。</p><p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p><h5 id="3、与红黑树比较"><a href="#3、与红黑树比较" class="headerlink" title="3、与红黑树比较"></a>3、与红黑树比较</h5><p>红黑树等平衡树也可以用来实现索引，但是文件系统以及数据库系统普遍采用B+ Tree作为索引结构，这是因为B+树访问磁盘数据有更高的性能。</p><h6 id="（1）B-Tree有更低的树高"><a href="#（1）B-Tree有更低的树高" class="headerlink" title="（1）B+ Tree有更低的树高"></a>（1）B+ Tree有更低的树高</h6><p>平衡树的树高O(h)=O(logdN)，其中d为每个节点的出度。红黑树的出度为2，而B+ Tree的出度一般非常大，所以红黑树的树高h很明显比B+ Tree大非常多。</p><h6 id="（2）磁盘访问原理"><a href="#（2）磁盘访问原理" class="headerlink" title="（2）磁盘访问原理"></a>（2）磁盘访问原理</h6><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块成为一页，内存与磁盘以页为单位交换数据，数据库系统将索引的一个节点的大小设置为页的大小，使得一次I/O就能完全载入一个节点。</p><p>如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ Tree相对于红黑树有更低的树高，进行寻道的次数和树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以B+ Tree更适合磁盘数据的读取。</p><h6 id="（3）磁盘预读特性"><a href="#（3）磁盘预读特性" class="headerlink" title="（3）磁盘预读特性"></a>（3）磁盘预读特性</h6><p>为了减少磁盘I/O操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快，并且可以利用预读特性，相邻的节点也能被预先载入。</p><h4 id="三、MySQL有哪些索引"><a href="#三、MySQL有哪些索引" class="headerlink" title="三、MySQL有哪些索引"></a>三、MySQL有哪些索引</h4><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现细节。</p><h5 id="1、B-Tree-索引"><a href="#1、B-Tree-索引" class="headerlink" title="1、B+ Tree 索引"></a>1、B+ Tree 索引</h5><p>是大多数MySQL存储引擎的默认索引类型。</p><p>建立索引后，不需要再进行全表扫描，只需要对树进行搜索即可，所以在查找效率上会高很多。</p><p>B+ Tree的有序性，不仅可以用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引，多个索引共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB的B+ Tree索引分为主索引和辅助索引。主索引的叶子节点data域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p>而辅助索引的叶子节点的data域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p><h5 id="2、哈希索引"><a href="#2、哈希索引" class="headerlink" title="2、哈希索引"></a>2、哈希索引</h5><p>哈希索引能以O(1)时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精准查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在B+ Tree索引之上再创建一个哈希索引，这样就让B+ Tree索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h5 id="3、全文索引"><a href="#3、全文索引" class="headerlink" title="3、全文索引"></a>3、全文索引</h5><p>MyISAM存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用MATCH AGAINST，而不是普通的WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB存储引擎在MySQL5.6.4版本中也开始支持全文索引。</p><h5 id="4、空间数据索引"><a href="#4、空间数据索引" class="headerlink" title="4、空间数据索引"></a>4、空间数据索引</h5><p>MyISAM存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><h4 id="四、索引的优化"><a href="#四、索引的优化" class="headerlink" title="四、索引的优化"></a>四、索引的优化</h4><h5 id="1、独立的列"><a href="#1、独立的列" class="headerlink" title="1、独立的列"></a>1、独立的列</h5><p>在进行查询时，索引列不能是表达式的一部分，也不能式函数的一部分，否则无法使用索引。例如以下查询不能使用actor_id列的索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 &#x3D; 5;</span><br></pre></td></tr></table></figure><h5 id="2、多列索引"><a href="#2、多列索引" class="headerlink" title="2、多列索引"></a>2、多列索引</h5><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用单列索引性能更好。例如以下语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT file_id,actor_id FROM sakila.film_actor WHERE actor_id &#x3D; 1 AND film_id &#x3D; 1;</span><br></pre></td></tr></table></figure><h5 id="3、索引列的顺序"><a href="#3、索引列的顺序" class="headerlink" title="3、索引列的顺序"></a>3、索引列的顺序</h5><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也就越高。</p><p>例如下面语句显示的结果中customer_id的选择性比staff_id更高，因此最好把customer_id列挡在多列索引的前面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT staff_id)&#x2F;COUNT(*) AS staff_id_selectivity,</span><br><span class="line">COUNT(DISTINCT customer_id)&#x2F;COUNT(*) AS customer_id_selectivity,</span><br><span class="line">COUNT(*)</span><br><span class="line">FROM payment;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure><h5 id="4、前缀索引"><a href="#4、前缀索引" class="headerlink" title="4、前缀索引"></a>4、前缀索引</h5><p>对于BLOB、TEXT、和VARCHAR类型的列，必须使用前缀索引，只索引开始的部分字符。</p><ul><li>1、前缀长度的选取需要根据索引选择性来确定。例如以下语句（假设1000万条数据）：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM x_test WHERE x_name &#x3D; &#39;1892008.205824857823401.800099203178258.8904820949682635656.62526521254&#39;;</span><br></pre></td></tr></table></figure><p>查询时间:2.253s;</p><ul><li>2、添加前缀索引 ( 以第一位字符创建前缀索引 )</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table x_test add index(x_name(1))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM x_test WHERE x_name &#x3D; &#39;1892008.205824857823401.800099203178258.8904820949682635656.62526521254&#39;;</span><br></pre></td></tr></table></figure><p>查询时间:3.291s,当使用第一位字符创建前缀索引后 貌似查询的时间更长了，因为只第一位字符而言索引值的重读性太大了</p><ul><li>3、重新建立前缀索引 这次以前4位字符来创建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table x_test add index(x_name(4));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM x_test WHERE x_name &#x3D; &#39;1892008.205824857823401.800099203178258.8904820949682635656.62526521254&#39;;</span><br></pre></td></tr></table></figure><p>查询时间:0.703s，这次以前4位创建索引 大大减少了索引值的重复性 查询速度从3秒提升到0.7秒。</p><p>总之，前缀数要根据重复度视情况而定。</p><h5 id="5、覆盖索引"><a href="#5、覆盖索引" class="headerlink" title="5、覆盖索引"></a>5、覆盖索引</h5><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h4 id="五、索引的优点"><a href="#五、索引的优点" class="headerlink" title="五、索引的优点"></a>五、索引的优点</h4><ul><li>大大减少了服务器需要扫描的数据行数。</li><li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li><li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li></ul><h4 id="六、索引的使用条件"><a href="#六、索引的使用条件" class="headerlink" title="六、索引的使用条件"></a>六、索引的使用条件</h4><ul><li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li><li>对于中到大型的表，索引就非常有效；</li><li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;提到数据库索引，大家应该都不陌生，但它的底层原理是什么呢，在此将最近所学的记录一下~&lt;/p&gt;
&lt;h4 id=&quot;一、什么是索
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>fail-fast/safe迭代器区别</title>
    <link href="http://yoursite.com/2020/06/16/fail-fast-safe/"/>
    <id>http://yoursite.com/2020/06/16/fail-fast-safe/</id>
    <published>2020-06-16T08:09:09.000Z</published>
    <updated>2020-06-16T08:09:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever </p></blockquote><p>最近在看Java容器，在此记录下fail-fast和fail-safe两种迭代器的区别。</p><h4 id="1-fail-fast"><a href="#1-fail-fast" class="headerlink" title="1.fail-fast"></a>1.fail-fast</h4><p>fail-fast迭代器，如果直接在容器上进行遍历，在遍历过程中，一旦发现容器中的数据被修改了(比如增加、删除或者修改)，会立刻抛出ConcurrentModificationException异常导致遍历失败。</p><p>原因：在迭代的时候，先计算一个modCount变量，然后当执行hasNext()方法时，要判断modCount是否等于expectedModCount值，如果是，就返回遍历，否则就抛出异常，终止遍历。</p><p>注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p><p>场景：java.util包下的集合类(比如HashMap和ArrayList)都是fail-fast的，不能在多线程下发生并发修改。</p><h4 id="2-fail-safe"><a href="#2-fail-safe" class="headerlink" title="2.fail-safe"></a>2.fail-safe</h4><p>采用fail-safe迭代器机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有的集合内容，在拷贝的集合上进行遍历。</p><p>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会抛出异常。</p><p>缺点：基于对原集合的克隆虽避免了ConcurrentModificationException,但迭代器并不能访问到修改后的内容，所以不适用于实时性要求比较高的场景。</p><p>场景：java.util.concurrent包下的容器(比如ConcerrentHashMap和CopyOnWriteArrayList)都是fail-safe，可以在多线程下并发使用，并发修改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近在看Java容器，在此记录下fail-fast和fail-safe两种迭代器的区别。&lt;/p&gt;
&lt;h4 id=&quot;1-fa
      
    
    </summary>
    
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java编程" scheme="http://yoursite.com/tags/Java%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Web页面的请求过程</title>
    <link href="http://yoursite.com/2020/05/20/web1/"/>
    <id>http://yoursite.com/2020/05/20/web1/</id>
    <published>2020-05-20T03:44:35.000Z</published>
    <updated>2020-05-20T03:44:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever</p></blockquote><p>当我们在浏览器查资料，输入所需要的网址时，按下回车，一个网页便会呈现在大家的眼前，就这几秒钟你知道浏览器到底发生了什么嘛？</p><p>本文就讲讲这个过程发生了什么吧？</p><pre class="mermaid">graph LR   输入URL --> DHCP配置主机信息   DHCP配置主机信息 --> ARP解析MAC地址   ARP解析MAC地址 --> DNS解析域名   DNS解析域名 --> HTTP请求页面</pre><ul><li><p><strong>1.URL</strong></p><p>输入所需网址</p></li><li><p><strong>2.DHCP配置主机信息</strong></p><ul><li>如果主机最开始没有IP地址以及其他信息，那么就需要先使用DHCP来获取</li><li>主机会生成一个DHCP请求报文，并将这个报文放入具有目的端口67和源端口68的UDP报文段中。</li><li>该报文段则被放入在一个具有广播IP目的地址(255.255.255.255)和源IP地址(0.0.0.0)的IP数据报中。</li><li>该数据报则被放置到MAC帧中，该帧具有目的地址FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备上。</li><li>连接在交换机的DHCP服务器收到广播帧之后，不断地向上分解得到IP数据报，UDP报文段，DHCP请求报文，之后生成DHCP ACK报文，该报文 包含以下信息：IP地址，DNS服务器地IP地址，默认网关路由器的IP地址和子网掩码。该报文被放入UDP报文段中，UDP报文段有被放入IP数据报中，最后放入MAC帧中。</li><li>该帧的目的地址是请求主机的MAC地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了MAC地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li><li>主机收到该帧后，不断分解得到DHCP报文。之后就配置它的IP地址，子网掩码和DNS服务器的IP地址，并在其IP转发表中安装默认网关。</li></ul></li><li><p><strong>3.ARP解析MAC地址</strong></p><ul><li>主机通过浏览器生成一个TCP套接字，套接字向HTTP服务器发送HTTP请求，为了生成该套接字，主机需要知道网站的域名对应的IP地址</li><li>主机生成一个DNS查询报文，该报文具有53号端口，因为DNS服务器的端口号是53。</li><li>该DNS查询报文被放入目的地址为DNS服务器IP地址的IP数据报中</li><li>该IP数据报被放入一个以太网帧中，该帧将发送到网关路由器</li><li>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</li><li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li><li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li></ul></li><li><p><strong>4.DNS解析域名</strong></p><ul><li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li><li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li><li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li><li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li><li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li></ul></li><li><p><strong>5.HTTP请求页面</strong></p><ul><li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li><li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li><li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li><li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li><li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li><li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我们在浏览器查资料，输入所需要的网址时，按下回车，一个网页便会呈现在大家的眼前，就这几秒钟你知道浏览器到底发生了什么嘛？&lt;
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Web页面的请求过程" scheme="http://yoursite.com/tags/Web%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>TCP之3次握手和4次挥手</title>
    <link href="http://yoursite.com/2020/05/20/TCP1/"/>
    <id>http://yoursite.com/2020/05/20/TCP1/</id>
    <published>2020-05-20T03:22:15.000Z</published>
    <updated>2020-05-20T03:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever</p></blockquote><h4 id="三次握手-three-way-handshake"><a href="#三次握手-three-way-handshake" class="headerlink" title="三次握手(three-way handshake)"></a>三次握手(three-way handshake)</h4><p><strong>意义</strong></p><p>TCP位于传输层，作用就是提供可靠安全的字节流服务，为了准确无误地将数据传送到客户或服务器，TCP协议则采纳了三次握手策略。</p><p><strong>过程</strong></p><p><img src="/2020/05/20/TCP1/tcp3.png" alt="TCP三次握手"><span class="img-alt">TCP三次握手</span></p><p>假设A为客户端，B为服务器端。</p><ul><li>首先B处于LISTEN(监听)状态，等待客户的连接请求。</li><li>A向B发送连接请求报文，SYN(同步)=1,ACK(确认)=0,选择一个初始地序号x。</li><li>B收到连接请求报文，如果同意建立连接，则向A发送连接确认报文，SYN=1，ACK=1，确认号为x+1，同时也选择一个初始的序号y。</li><li>A收到B的连接确认报文后，还要向B发出确认，确认号为y+1,序号为x+1。</li><li>B收到A的确认后，连接建立。</li></ul><p>形象化说法就是：</p><ul><li>Client:嗨，A，是我，听到没？</li><li>Server:我听到了，你能听到我没？</li><li>Client:好的，我们都能互相听到了，可以建立连接，通信了。</li></ul><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送地连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回地连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留地连接请求最后还是会达到服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有三次握手，客户端就会忽略服务器之后发送地对滞留连接请求地连接确认，不进行第三次握手，因此就不会在此打开连接。</p><h4 id="四次挥手-four-way-wavehand"><a href="#四次挥手-four-way-wavehand" class="headerlink" title="四次挥手(four-way wavehand)"></a>四次挥手(four-way wavehand)</h4><p><strong>意义</strong></p><p>客户端发送了FIN连接释放报文之后，服务器收到了这个报文，就进入了CLOSE-WAIT状态，这个状态是为了让服务器端发送还未还未传送完毕的数据，传送完毕后，服务器就会发送FIN连接释放报文。</p><p><strong>过程</strong></p><p><img src="/2020/05/20/TCP1/tcp4.png" alt="TCP四次挥手"><span class="img-alt">TCP四次挥手</span></p><ul><li>A发送连接释放报文，FIN=1.</li><li>B收到之后发出确认，此时TCP属于半关闭状态，B能向A发送数据但是A不能向B发送数据。</li><li>当B不再需要连接时，发送连接释放报文，FIN=1。</li><li>A收到后发出确认，进入TIME_WAIT状态，等待2MSL(最大报文存活时间)后释放连接。</li><li>B收到A的确认后释放连接</li></ul><p>形象化说法就是：</p><ul><li>Client:我所有数据都传完了</li><li>Server:我已经全部接收到了，但是等等我，我还没传完</li><li>Server:好了，我也已经传完了</li><li>Client:好的，那我们释放连接，通信结束。</li></ul><p><strong>TIME_WAIT</strong></p><p>在客户端接收到服务端的FIN报文后进入此状态，此时并不是直接进入CLOSED状态，还需要等待一个时间计时器设置的时间2MSL(超过此时间则结束TCP连接)，这么做的理由为：</p><ul><li>确保最后一个确认报文能够到达。如果B没收到A发送的确认报文，那么就会重新发送连接释放请求报文，A等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p><strong>常见问题</strong></p><ul><li><p>为什么连接的时候是三次握手，关闭的时候却是四次挥手？</p><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来确认的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步挥手。</p></li><li><p>如果已经建立了连接，但是客户端突然出现故障了怎么办？</p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;三次握手-three-way-handshake&quot;&gt;&lt;a href=&quot;#三次握手-three-way-handsh
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP之3次握手和4次挥手" scheme="http://yoursite.com/tags/TCP%E4%B9%8B3%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C4%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="http://yoursite.com/2020/05/18/HTTPStatusCode/"/>
    <id>http://yoursite.com/2020/05/18/HTTPStatusCode/</id>
    <published>2020-05-18T03:40:36.000Z</published>
    <updated>2020-05-18T03:40:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever</p></blockquote><p>最近又重温了一遍计算机网络，发现还是有好多知识点没掌握(又找借口，就是没学好🤣)。</p><p>作为一个Web端程序猿，怎么能不知道HTTP状态码呢！今天就来讲讲~</p><p>服务器返回的响应报文中第一行会有个状态行，它包含了状态码以及原因短语，用来告诉客户端请求的结果。</p><table><thead><tr><th align="center">状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td align="center">1XX</td><td>Informational(信息性状态码)</td><td>接收的请求正在处理</td></tr><tr><td align="center">2XX</td><td>Success(成功状态码)</td><td>请求正常处理完毕</td></tr><tr><td align="center">3XX</td><td>Redirection(重定向状态码)</td><td>需要进行附加操作以完成请求</td></tr><tr><td align="center">4XX</td><td>Client Error(客户端错误状态码)</td><td>服务器无法处理请求</td></tr><tr><td align="center">5XX</td><td>Server Error(服务器错误状态码)</td><td>服务器处理请求出错</td></tr></tbody></table><p><strong>1XX 信息</strong></p><ul><li><strong>100 Continue:</strong> 表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><p><strong>2XX 成功</strong></p><ul><li><strong>200 OK</strong></li><li><strong>204 No Content:</strong>请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送消息，而不需要返回数据时使用。</li><li><strong>206 Partial Content:</strong>表示客户端进行了范围请求，响应报文包含由Content-Range指定范围的实体内容。</li></ul><p><strong>3XX 重定向</strong></p><ul><li><strong>301 Moved Permanently:</strong>永久性重定向</li><li><strong>302 Found:</strong>临时性重定向</li><li><strong>303 See Other:</strong>和302有着相同的功能，但是303明确要求客户端应该采用GET方法获取资源</li><li><strong>304 Not Modified:</strong>如果请求报文首部包含一些条件，例如：If-Match,If-Modified-Since,If-None-Match,If-Range,If-Unmodified-Since,如果不满足条件，则服务器会返回304状态</li><li><strong>307 Temporary Redirect:</strong>临时重定向，与302的含义类似，但是307要求浏览器不会把重定向请求的POST方法改为GET方法。</li></ul><p><strong>4XX 客户端错误</strong></p><ul><li><strong>400 Bad Request:</strong>请求报文中存在语法错误</li><li><strong>401 Unauthorized:</strong>该状态码表示发送的请求需要有认证信息(BASIC认证，DIGEST认证)。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden:</strong>请求被拒绝</li><li><strong>404 Not Found</strong></li></ul><p><strong>5XX 服务器错误</strong></p><ul><li><strong>500 Internal Server Error:</strong>服务器正在执行请求时发生错误</li><li><strong>503 Service Unavailable:</strong>服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近又重温了一遍计算机网络，发现还是有好多知识点没掌握(又找借口，就是没学好🤣)。&lt;/p&gt;
&lt;p&gt;作为一个Web端程序猿，
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP状态码" scheme="http://yoursite.com/tags/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>递归与迭代的区别</title>
    <link href="http://yoursite.com/2020/05/03/fornote1/"/>
    <id>http://yoursite.com/2020/05/03/fornote1/</id>
    <published>2020-05-03T12:05:58.000Z</published>
    <updated>2020-05-03T12:05:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever</p></blockquote><p>递归与迭代还是会经常遇到的，不少小伙伴会经常理不清这两者的区别(包括我在内😏)，在此整理一下，希望对小伙伴们有帮助😎</p><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>递归到底是啥呢？</p><p><strong>递归</strong>(recursion):指的是在函数运行中调用函数自身的方法(A调用A)，但是递归不能一直让其递归下去(那不死循环啦😅)，所以构造递归方法必须满足两个条件：</p><ul><li><p>其一，子方法与原来的方法必须是处理的同一个问题</p></li><li><p>其二，不能无限制调用自身，必须有个终止条件，得到所需结果</p></li></ul><p>说了这么多，不够形象，说一些例子吧！</p><ul><li><p>斐波那契数列—指的是这样一个数列：1、1、2、3、5、8、13、21、……<br>这个数列从第三项开始，每一项都等于前两项之和，如何递归实现呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> n; <span class="comment">// n = 0, 1时给出recursion终止条件  </span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>阶乘 n! = n * (n-1) * (n-2) * …* 1(n&gt;0)，递归实现？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n*factorial(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了这两个例子，大家应该都理解了吧😊</p></li></ul><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><p>那迭代是啥呢？</p><p><strong>迭代</strong>(iteration):是利用已知的变量值，根据递推公式不断演进得到变量新值。简单地说，迭代是函数内某段代码实现循环。</p><p>都是循环，那迭代的循环和咱常见的普通循环有啥区别呢？</p><p>迭代与普通循环的<strong>区别</strong>：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</p><p>举几个栗子吧！</p><ul><li><p>斐波那契数列(不错，又是我)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用2个指针one、two分别指向前面2个数，然后相加移动</span></span><br><span class="line">    <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> two = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//最终结果</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        res = one + two;</span><br><span class="line">        one = two;</span><br><span class="line">        two = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>阶乘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过上面几个例子，大家需要注意下呀，通常情况下，<strong>在循环的次数较大时，迭代的效率明显高于递归，即迭代的时间复杂度低于递归的时间复杂度</strong>。</p><p><strong>end~&lt;(￣︶￣)↗[GO!]</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;递归与迭代还是会经常遇到的，不少小伙伴会经常理不清这两者的区别(包括我在内😏)，在此整理一下，希望对小伙伴们有帮助😎&lt;/
      
    
    </summary>
    
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>nginx初体验</title>
    <link href="http://yoursite.com/2020/05/03/nginxNote1/"/>
    <id>http://yoursite.com/2020/05/03/nginxNote1/</id>
    <published>2020-05-02T16:12:52.000Z</published>
    <updated>2020-05-05T16:12:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever</p></blockquote><h4 id="1、什么是nginx"><a href="#1、什么是nginx" class="headerlink" title="1、什么是nginx?"></a>1、什么是nginx?</h4><p>众所周知，nginx是一个高性能的HTTP和反向代理服务器，它占有内存少，并发能力强，实现上注重效率，能够接收高负载的考验，受到很多用户的青睐。</p><h4 id="2、什么是正向代理"><a href="#2、什么是正向代理" class="headerlink" title="2、什么是正向代理?"></a>2、什么是正向代理?</h4><p>说到反向代理，必须提一下正向代理。所谓正向代理，如果把本地网络外的网络(简称外网)想象成一个你要去的地方，假设本地网络中客户端要去外网，则需要通过代理服务器，这种代理服务就称为正向代理。</p><p>这也就需要在客户端(比如:浏览器)，配置代理服务器，通过代理服务器进行网络访问(注意:正向代理代理的是客户端)。</p><p>举个栗子:在现实网络中，我们是无法访问谷歌的，要想能够访问到，就需要某个东西代理访问(比如通过xxx.com网站)，但用户操作时是输入的<a href="http://www.google.com。" target="_blank" rel="noopener">www.google.com。</a></p><pre class="mermaid">graph LR   客户端. --> www.xxx.com   www.xxx.com --> www.google.com   客户端 --> www.google.com</pre><h4 id="3、什么是反向代理？"><a href="#3、什么是反向代理？" class="headerlink" title="3、什么是反向代理？"></a>3、什么是反向代理？</h4><p>说回反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需将请求发送给反向代理服务器(比如此处的nginx)，再由反向代理服务器去选择最终服务器，请求到数据后，再返回给客户端。而此时的反向代理服务器和目标服务器对外就是一个服务器，能够看到的是代理服务器地址，隐藏了真实服务器IP地址(反向代理代理的为服务器)</p><pre class="mermaid">graph LR   客户端 --> 80反向代理服务器   80反向代理服务器 --> 8090目标服务器比如tomcat服务器   80反向代理服务器 --> 8091目标服务器比如tomcat服务器   80反向代理服务器 --> ...</pre><h4 id="4、什么是负载均衡？"><a href="#4、什么是负载均衡？" class="headerlink" title="4、什么是负载均衡？"></a>4、什么是负载均衡？</h4><p>说nginx，必须要提<strong>负载均衡</strong>。</p><p>客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。这种处理逻辑没有任何问题，当并发请求较少时比较合适，节省资源。</p><pre class="mermaid">graph LR   客户端 --> 服务端   服务端 --> 数据库   数据库 --> 服务端   服务端 --> 客户端</pre><p>但这种请求会造成服务器响应客户端的请求日益缓慢，并发量大时，还容易造成服务器的崩溃，性能大打折扣。</p><p>因此，单个服务器解决不了，我们就增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的<strong>负载均衡</strong>，如图所示：</p><pre class="mermaid">graph LR   客户端 --> 80反向代理服务器   80反向代理服务器 --> 8090目标服务器比如tomcat服务器   80反向代理服务器 --> 8091目标服务器比如tomcat服务器   80反向代理服务器 --> ...</pre><h4 id="5、什么是动静分离？"><a href="#5、什么是动静分离？" class="headerlink" title="5、什么是动静分离？"></a>5、什么是动静分离？</h4><p>传统的部署都是将静态文件和动态资源部署到服务器，如图所示：</p><pre class="mermaid">graph LR   客户端-浏览器 --> 反向代理服务器   反向代理服务器 --> 服务器-将css.js等静态文件和servlet等动态资源部署到服务器</pre><p>而现在在前后端分离的趋势下，动静分离显得格外重要，而且更加方便，哈哈哈，话不多说，上图：</p><pre class="mermaid">graph LR   客户端-浏览器 --> 反向代理服务器   反向代理服务器 --> 服务器-将servlet等动态资源部署到服务器   反向代理服务器 --> 静态资源</pre><h4 id="6、配置文件"><a href="#6、配置文件" class="headerlink" title="6、配置文件"></a>6、配置文件</h4><p>说了这么多，看看如何配置nginx吧！我们需要配置<em>nginx.conf</em>文件。</p><p><strong>组成</strong></p><p><em>nginx.conf</em>文件由三部分组成</p><ul><li><p>第一部分 全局块</p><p>这部分主要设置一些影响nginx服务器整体运行的配置指令，主要包括配置运行Nginx服务器的用户(组)、允许生成的worker、<br>process数，进程PID存放路径、日志存放路径和类似以及配置文件的引入等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">#这是nginx服务器并发处理服务的关键配置，work_processes值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。</span><br><span class="line">worker_processes  1;</span><br><span class="line">#error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line">#pid        logs&#x2F;nginx.pid;</span><br></pre></td></tr></table></figure></li><li><p>第二部分 events块</p><p>events块涉及的指令主要影响Nginx服务器与用户的网络连接，常用的设置，包括是否开启对多work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个work process可以同时支持的最大连接数等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#此默认示例表示每个work process支持的最大连接数为1024</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第三部分 http块</p><p>Nginx服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块配置都在这里，http全局块配置的指令包括文件引入、MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上限等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">include       mime.types;</span><br><span class="line">default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">#log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">#&#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">#&#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">#access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">sendfile        on;</span><br><span class="line">#tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">#keepalive_timeout  0;</span><br><span class="line">keepalive_timeout  65;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全不一样的，该技术的产生是为了节省互联网服务器硬件成本。每个http块可以包括多个server块，而每个server块就相当于一个虚拟主机。而每个server块也分为全局server块，以及可以同时包含多个location块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#全局server块</span><br><span class="line">server &#123;</span><br><span class="line">  listen       80; #默认监听端口</span><br><span class="line">  server_name  localhost;</span><br><span class="line">#charset koi8-r;</span><br><span class="line"></span><br><span class="line">#access_log  logs&#x2F;host.access.log  main;</span><br><span class="line">#location块</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">   root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>动静分离配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 上游服务器</span><br><span class="line">upstream group&#123;</span><br><span class="line">#weight即权重，数值越大，优先级越高</span><br><span class="line">server 127.0.0.1:8090 weight&#x3D;2;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"># 配置服务器</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;group&#x2F;;</span><br><span class="line">tcp_nodelay     on;</span><br><span class="line">proxy_set_header Host            $host;</span><br><span class="line">        proxy_set_header X-Real-IP       $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br><span class="line"># 配置静态资源</span><br><span class="line">    location ~ .*\.(js|css|ico|png|jpg|eot|svg|ttf|woff|html|txt|pdf|gltf|) &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">expires 30d; #缓存30天</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>通过location指定不同的后缀名实现不同的请求转发。通过<strong>expires</strong>参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体Expires定义: 是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常<strong>适合不经常变动的资源</strong>。(如果经常更新的文件，不建议使用Expires来缓存)，如果设置30d, 表示在这30天之内访问这个URL, 发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304,如果有修改，则直接从服务器重新下载，返回状态码200。</p><p><strong>配置负载均衡</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#上游服务器</span><br><span class="line">upstream group&#123;</span><br><span class="line">#weight即权重，数值越大，优先级越高</span><br><span class="line">    server 192.168.0.12:80 weight&#x3D;1;</span><br><span class="line">    server 192.168.0.11:80 weight&#x3D;2;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    default_type  text&#x2F;html;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;&#123;</span><br><span class="line">        echo &quot;hello&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location &#x2F;a&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;group&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>负载分配策略</strong></p><ul><li><p>1、轮询(默认)</p><p>每个请求按时间顺序逐一分配到不 同的后端服务器，如果后端服务器down掉，能自动剔除</p></li><li><p>2、weight<br>weight代表权重默认为1,权重越高被分配的客户端越多。<br>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。例如: 。</p></li><li><p>3、ip hash</p><p>每个请求按访问ip的hash结果分配, 这样每个访客固定访问一个后端服务器,可以解诀session的问题。例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream server pool&#123;</span><br><span class="line">  ip_ hash</span><br><span class="line">  server 192.168.0.12:80</span><br><span class="line">  server 192.168.0.11:80</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>4、fair (第三方)<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream server_pool </span><br><span class="line">server 192.168.0.12:80;</span><br><span class="line">server 192.168.0.11:80;</span><br><span class="line">fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7、Nginx原理浅谈"><a href="#7、Nginx原理浅谈" class="headerlink" title="7、Nginx原理浅谈"></a>7、Nginx原理浅谈</h4><p><strong>①master和worker</strong></p><pre class="mermaid">graph TB   管理员--信号--> master进程   master进程--信号--> worker1进程   master进程 --信号--> worker2进程   master进程 --信号--> worker3进程   worker1进程 --连接--- Client1   worker1进程 --连接--- Client2   worker2进程 --连接--- Client3   worker2进程 --连接--- Client4   worker3进程 --连接--- Client5   worker3进程 --连接--- Client6</pre><p><strong>②worker如何进行工作的</strong></p><pre class="mermaid">graph LRclient --> MasterMaster--管理-监控---worker1Master--管理-监控---worker2Master--管理-监控---worker3Master--管理-监控---worker4worker1--争抢-->clientworker2--争抢-->clientworker3--争抢-->clientworker4--争抢-->clientworker1--争抢到-获取-->Tomcat1</pre><p>Master负责管理，监控并告知worker是否可以连接client，并请求连接服务器端。</p><p><strong>③一个master和多个worker的好处</strong></p><p>首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次,采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。当然，worker进程的异常退出，肯定是程序有bug了，异常退出，会导致当前worker.上的所有请求失败，不过不会影响到所有请求，所以降低了风险。</p><p><strong>④设置多少个worker合适</strong></p><p>Nginx同redis类似都采用了io多路复用机制，每个worker都是一个独立的进程， 但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求，即使是 千上万个请求也不在话下。每个worker的线程可以把一个cpu的性能发挥到极致。所以worker数和服务器的cpu数相等是最为适宜的。设少了会浪费cpu,设多了会造成cpu频繁切换上下文带来的损耗。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 设置worker数量</span><br><span class="line">worker.processes 4 </span><br><span class="line"></span><br><span class="line"># work绑定cpu(4work绑定4cpu)</span><br><span class="line">worker_cpu_affinity 0001 0010 0100 1000</span><br><span class="line"></span><br><span class="line"># work绑定cpu (4work绑定8cpu中的4个)</span><br><span class="line">worker_cpu_affinity 0000001 00000010 00000100 00001000</span><br></pre></td></tr></table></figure><p><strong>⑤连接数worker_ connection</strong></p><p>这个值是表示每个worker进程所能建立连接的最大值，所以，一个nginx 能建立的最大连接数，应该是worker.connections * worker processes。当然，这里说的是最大连接数，对于HTTP 请求本地资源来说，能够支持的最大并发数量是worker.connections * worker processes；如果是支持http1.1的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是: worker.connections * worker.processes / 2,；而如果是HTTP作为反向代理来说，最大并发数量应该是worker.connections * worker_proceses/4.。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。</p><p><strong>举例</strong></p><p>第一个: 发送请求，占用了woker的几个连接数?<br>答案: 2或者4个。</p><p>第二个: nginx有一个master,有四个woker,每个woker支持最大的连接数1024,支持的最大并发数是多少?<br>答案：普通的静态访问最大并发数是: worker connections * worker processes /2，<br>而如果是HTTP作为反向代理来说，最大并发数量应该是worker connections * worker processes/4</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;1、什么是nginx&quot;&gt;&lt;a href=&quot;#1、什么是nginx&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>关于我</title>
    <link href="http://yoursite.com/2020/05/01/aboutme/"/>
    <id>http://yoursite.com/2020/05/01/aboutme/</id>
    <published>2020-05-01T15:11:44.000Z</published>
    <updated>2020-05-02T12:02:23.207Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pain is temporary,quitting lasts forever</p></blockquote><p>记得几年前就曾做了一个属于自己的博客，无奈当时没有坚持维护，如今正好有些时间，做了这个，将自己的读书，学习，生活记录于此。</p><p>希望这次我能长期维护这个博客，加油💪</p><p>要是偶然你们能够看到，希望所记录的东西能与你们分享，要是对你们有帮助那就更好了！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pain is temporary,quitting lasts forever&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记得几年前就曾做了一个属于自己的博客，无奈当时没有坚持维护，如今正好有些时间，做了这个，将自己的读书，学习，生活记录于此。&lt;
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="关于我" scheme="http://yoursite.com/tags/%E5%85%B3%E4%BA%8E%E6%88%91/"/>
    
  </entry>
  
</feed>
